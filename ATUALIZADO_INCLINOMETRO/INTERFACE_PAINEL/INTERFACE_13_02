import tkinter as tk
from tkinter import ttk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import random
import time
import threading
import os
from collections import deque
import serial
import struct

# Configura a comunicação serial
ser = serial.Serial('COM8', 115200, timeout=1)  # Ajuste 'COM8' conforme necessário

def ler_dados():
    if ser.in_waiting >= 13:  # Garante que há pelo menos 13 bytes no buffer
        dados = ser.read(13)  # Lê 13 bytes (1 cabeçalho + 12 dados)

        if dados[0] == 0xAA:  # Verifica se o cabeçalho está correto
            # Desempacota 6 valores inteiros (2 bytes cada, big-endian)
            v1, v2, v3, v4, v5, v6 = struct.unpack('>hhhhhh', dados[1:])

            # Converte os valores para float
            v1, v2, v3, v4, v5, v6 = [v / 100.0 for v in (v1, v2, v3, v4, v5, v6)]

            print(f"V1: {v1:.2f}, V2: {v2:.2f}, V3: {v3:.2f}, V4: {v4:.2f}, V5: {v5:.2f}, V6: {v6:.2f}")
            return v1, v2, v3, v4, v5, v6  # Retorna os valores convertidos
        else:
            print("Cabeçalho incorreto, descartando pacote!")
            ser.reset_input_buffer()  # Limpa o buffer para evitar leituras erradas
    return None  # Retorna None se não houver leitura válida

class DynamicPlotApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Gráficos Dinâmicos")

        # Variáveis para gravação
        self.recording = False
        self.paused = False
        self.data = []

        # Configurar interface
        self.create_widgets()
        tamanho_maximo = 1000000

        # Variáveis simuladas
        self.x_data = deque(maxlen=tamanho_maximo)
        self.y1_data = deque(maxlen=tamanho_maximo)
        self.y2_data = deque(maxlen=tamanho_maximo)
        self.y3_data = deque(maxlen=tamanho_maximo)
        self.gx_data = deque(maxlen=tamanho_maximo)  # Dados de referência (Pitch)
        self.gy_data = deque(maxlen=tamanho_maximo)  # Dados de referência (Roll)
        self.gz_data = deque(maxlen=tamanho_maximo)  # Dados de referência (Position)

        # Threading lock para segurança
        self.lock = threading.Lock()

    def create_widgets(self):
        # Botões
        self.start_read = ttk.Button(self.root, text="START", command=self.start_read)
        self.start_read.grid(row=0, column=2, padx=5, pady=5)

        self.start_button = ttk.Button(self.root, text="Iniciar Gravação", command=self.start_recording)
        self.start_button.grid(row=0, column=0, padx=5, pady=5)

        self.pause_button = ttk.Button(self.root, text="Pausar/Retomar", command=self.pause_recording)
        self.pause_button.grid(row=0, column=1, padx=5, pady=5)

        self.stop_button = ttk.Button(self.root, text="Encerrar Gravação", command=self.stop_recording)
        self.stop_button.grid(row=1, column=2, padx=5, pady=5)

        # Figura e gráficos
        self.fig, self.axes = plt.subplots(3, 1, figsize=(10, 8))  # 3 gráficos em uma coluna
        self.fig.tight_layout(pad=3.0)

        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().grid(row=1, column=0, columnspan=2)

        # Configurar eixos
        self.ax1, self.ax2, self.ax3 = self.axes.flatten()
        self.ax1.set_title("Pitch")
        self.ax2.set_title("Roll")
        self.ax3.set_title("Position")

    def start_read(self):
        ser.write(b"R")
        print("Comando R enviado ao transmissor")

    def start_recording(self):
        ser.write(b"P")  # Envia o comando "START" para o transmissor
        print("P Enviado")
        self.recording = True
        self.paused = False
        threading.Thread(target=self.update_data, daemon=True).start()  # Thread para atualizar dados

    def pause_recording(self):
        self.paused = not self.paused  # Alterna entre pausado e retomado
        if self.paused:
            ser.write(b"R")
            print("Grafico Pausado")
        else:
            ser.write(b"P")
            print("Grafico Retomado")

    def stop_recording(self):
        self.recording = False
        self.save_data()

    def update_data(self):
        cont = 0
        while self.recording:
            if not self.paused:
                leitura = ler_dados()
                if leitura:
                    p, r, pos, a_p, a_r, a_pos = leitura

                    with self.lock:  # Garante acesso seguro aos dados
                        self.x_data.append(cont)
                        self.y1_data.append(p)
                        self.y2_data.append(r)
                        self.y3_data.append(pos)
                        self.gx_data.append(a_p)
                        self.gy_data.append(a_r)
                        self.gz_data.append(a_pos)
                        cont += 1

                    self.update_plots()
            time.sleep(0.5)  # Ajuste o intervalo conforme necessário

    def update_plots(self):
        with self.lock:  # Garante acesso seguro aos dados
            if self.x_data:
                # Gráfico 1: Pitch
                self.ax1.clear()
                self.ax1.plot(self.x_data, self.y1_data, label="Pitch (Sensor)", color="blue")
                self.ax1.plot(self.x_data, self.gx_data, label="Pitch (Referência)", color="red")
                self.ax1.set_title("Pitch")
                self.ax1.legend()

                # Gráfico 2: Roll
                self.ax2.clear()
                self.ax2.plot(self.x_data, self.y2_data, label="Roll (Sensor)", color="blue")
                self.ax2.plot(self.x_data, self.gy_data, label="Roll (Referência)", color="red")
                self.ax2.set_title("Roll")
                self.ax2.legend()

                # Gráfico 3: Position
                self.ax3.clear()
                self.ax3.plot(self.x_data, self.y3_data, label="Position (Sensor)", color="blue")
                self.ax3.plot(self.x_data, self.gz_data, label="Position (Referência)", color="red")
                self.ax3.set_title("Position")
                self.ax3.legend()

                self.canvas.draw()

    def save_data(self):
        dataID = random.randint(999, 9999)
        file_name = f'dados_gravados_{dataID}.txt'

        if self.x_data:
            folder_path = "C:\\Users\\bruno\\Desktop\\Solution\\TOUSANDOESSES\\painel_inclinometro\\dados"
            if not os.path.exists(folder_path):
                os.makedirs(folder_path)

            file_path = os.path.join(folder_path, file_name)
            with open(file_path, "w") as file:
                file.write("Timestamp, Pitch, Roll, Position\n")
                for t, y1, y2, y3 in zip(self.x_data, self.y1_data, self.y2_data, self.y3_data):
                    file.write(f"{t}, {y1:.2f}, {y2:.2f}, {y3:.2f}\n")

            print(f"Dados salvos em {file_path}")

# Criar aplicação
root = tk.Tk()
app = DynamicPlotApp(root)
root.mainloop()